// Version 1.2.4 d3-hilbert - https://github.com/vasturiano/d3-hilbert
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).d3=t.d3||{})}(this,(function(t){"use strict";t.hilbert=function(){var t=function(){function t(t,e,n,r){0==r&&(1==n&&(e[0]=t-1-e[0],e[1]=t-1-e[1]),e.push(e.shift()))}return{point2Distance:function(e,n,r){for(var i,o,u=0,a=[e,n],f=r/2;f>=1;f/=2)u+=f*f*(3*(i=(a[0]&f)>0)^(o=(a[1]&f)>0)),t(f,a,i,o);return u},distance2Point:function(e,n){for(var r,i,o=e,u=[0,0],a=1;a<n;a*=2)t(a,u,r=1&o/2,i=1&(o^r)),u[0]+=a*r,u[1]+=a*i,o/=4;return u}}}(),e={},n=1,r=4,i=!0;return e.canvasWidth=function(t){return arguments.length?(n=+t,e):n},e.order=function(t){return arguments.length?(r=+t,e):r},e.simplifyCurves=function(t){return arguments.length?(i=t,e):i},e.layout=function(o){var u=function(e,n,r,i,o){if(o){for(;!Number.isInteger(e)||!Number.isInteger(n);)e*=4,n*=4,r+=1;for(;!(e%4)&&!(n%4)&&r>0;)e/=4,n/=4,r-=1}var u=Math.pow(4,r);e=Math.min(e,u),n=Math.min(n,u-e);for(var a,f=Math.pow(2,r),s=i/f,l=t.distance2Point(e,f),c=[],h=l,d=1;d<n;d++)a=t.distance2Point(e+d,f),c.push(a[0]>h[0]?"R":a[0]<h[0]?"L":a[1]>h[1]?"D":"U"),h=a;return{cellWidth:s,startCell:l,pathVertices:c}}(o.start,o.length,r,n,i);return o.cellWidth=u.cellWidth,o.startCell=u.startCell,o.pathVertices=u.pathVertices,e},e.getValAtXY=function(e,i){var o=Math.pow(2,r),u=[e,i].map((function(t){return Math.floor(t*o/n)}));return t.point2Distance(u[0],u[1],o)},e.getXyAtVal=function(e){return e>Math.pow(4,r)||e<0?(console.error("Value is outside hilbert space boundaries."),null):t.distance2Point(e,Math.pow(2,r))},e},Object.defineProperty(t,"__esModule",{value:!0})}));
